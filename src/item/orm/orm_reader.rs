use std::cell::{Cell, RefCell};

use sea_orm::{DatabaseConnection, DbErr, EntityTrait, FromQueryResult, PaginatorTrait, Select};

use crate::{
    core::item::{ItemReader, ItemReaderResult},
    BatchError,
};

/// A reader for reading items from a database using SeaORM.
///
/// This reader provides an implementation of the `ItemReader` trait for SeaORM-based
/// database operations. It supports reading data from any database supported by SeaORM,
/// with optional pagination for efficient memory usage when dealing with large datasets.
///
/// # Design
///
/// The reader uses a buffered approach to balance performance and memory usage:
/// - **Connection Management**: Uses SeaORM's connection management for database operations
/// - **Pagination Support**: Optional pagination to avoid loading the entire result set into memory
/// - **Internal Buffering**: Maintains an internal buffer of items and only fetches new data when necessary
/// - **Position Tracking**: Tracks the current position using an offset counter
/// - **Type Safety**: Leverages SeaORM's type-safe query building and execution
/// - **Direct Entity Loading**: Works directly with SeaORM entity models without transformation
///
/// # How Pagination Works
///
/// When `page_size` is provided:
/// - Data is loaded in batches of `page_size` items using SeaORM's paginator
/// - When all items in a batch have been read, a new batch is loaded automatically
/// - The `offset` is used to determine the current page and position within the buffer
/// - Memory usage is bounded by the page size, making it suitable for large datasets
///
/// When `page_size` is not provided:
/// - All data is loaded in one query using SeaORM's `all()` method
/// - The `offset` is only used to track the current position in the buffer
/// - Suitable for smaller datasets where memory usage is not a concern
///
/// # Thread Safety
///
/// This reader is **not thread-safe** due to the use of `Cell` and `RefCell` for interior mutability.
/// It's designed for single-threaded batch processing scenarios. If you need concurrent access,
/// consider using multiple reader instances or implementing proper synchronization.
///
/// # Examples
///
/// ```
/// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
/// use spring_batch_rs::core::item::ItemReader;
/// use sea_orm::{Database, EntityTrait};
/// use serde::{Deserialize, Serialize};
///
/// // In a real application, you would have SeaORM entities generated from your database
/// // For this example, we'll show the structure but not actually create entities
/// // since that requires a database connection and entity generation
///
/// // Example entity structure (generated by sea-orm-cli):
/// // #[derive(Debug, Clone, DeriveEntityModel, Deserialize, Serialize)]
/// // #[sea_orm(table_name = "users")]
/// // pub struct Model {
/// //     #[sea_orm(primary_key)]
/// //     pub id: i32,
/// //     pub name: String,
/// //     pub email: String,
/// //     pub active: bool,
/// // }
/// //
/// // #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
/// // pub enum Relation {}
/// //
/// // impl ActiveModelBehavior for ActiveModel {}
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// // Create database connection
/// let db = Database::connect("sqlite::memory:").await?;
///
/// // Create a select query (in practice, this would use your actual entity)
/// // let query = user::Entity::find().filter(user::Column::Active.eq(true));
///
/// // Create the reader with pagination
/// // let reader = OrmItemReaderBuilder::new()
/// //     .connection(&db)
/// //     .query(query)
/// //     .page_size(100)
/// //     .build();
///
/// // Read items
/// // while let Some(user) = reader.read()? {
/// //     println!("Processing user: {}", user.name);
/// // }
/// # Ok(())
/// # }
/// ```
pub struct OrmItemReader<'a, I>
where
    I: EntityTrait,
{
    /// Database connection reference - borrowed for the lifetime of the reader
    /// This ensures the connection remains valid throughout the reader's lifecycle
    connection: &'a DatabaseConnection,

    /// SeaORM select query to execute
    /// This query is cloned for each page fetch to maintain immutability
    query: Select<I>,

    /// Optional page size for pagination
    /// When Some(size), data is loaded in chunks of this size
    /// When None, all data is loaded at once
    page_size: Option<u64>,

    /// Current offset for tracking position across all pages
    /// Uses Cell for interior mutability in single-threaded context
    /// This tracks the absolute position, not just within the current page
    offset: Cell<u64>,

    /// Internal buffer for storing fetched items from the current page
    /// Uses RefCell for interior mutability to allow borrowing during reads
    /// The buffer is cleared and refilled when a new page is loaded
    buffer: RefCell<Vec<I::Model>>,

    /// Current page number (used with pagination)
    /// Starts at 0 and increments when moving to the next page
    /// Only relevant when page_size is Some(_)
    current_page: Cell<u64>,
}

impl<'a, I> OrmItemReader<'a, I>
where
    I: EntityTrait,
    I::Model: FromQueryResult + Send + Sync + Clone,
{
    /// Creates a new `OrmItemReader`.
    ///
    /// This constructor initializes all the internal state needed for reading:
    /// - Sets up the buffer with appropriate capacity based on page_size
    /// - Initializes counters to zero
    /// - Stores references to the connection and query
    ///
    /// # Arguments
    ///
    /// * `connection` - The SeaORM database connection (must outlive the reader)
    /// * `query` - The SeaORM select query to execute (will be cloned for each page)
    /// * `page_size` - The number of items to read per page (None for no pagination)
    ///
    /// # Returns
    ///
    /// A new `OrmItemReader` instance ready for reading
    ///
    /// # Performance Notes
    ///
    /// - When page_size is provided, the buffer is pre-allocated with that capacity
    /// - This reduces memory allocations during reading
    /// - The query is stored by value and will be cloned for each page fetch
    pub fn new(
        connection: &'a DatabaseConnection,
        query: Select<I>,
        page_size: Option<u64>,
    ) -> Self {
        // Pre-allocate buffer capacity based on page size to reduce allocations
        let buffer = if let Some(page_size) = page_size {
            Vec::with_capacity(page_size as usize)
        } else {
            Vec::new()
        };

        Self {
            connection,
            query,
            page_size,
            offset: Cell::new(0), // Start at the beginning
            buffer: RefCell::new(buffer),
            current_page: Cell::new(0), // Start at page 0
        }
    }

    /// Reads a page of items from the database using SeaORM.
    ///
    /// This method executes the SeaORM query with pagination parameters (if page_size is set),
    /// and fills the internal buffer with the results. It uses SeaORM's async methods
    /// within a blocking context to maintain compatibility with the synchronous ItemReader trait.
    ///
    /// # Pagination Logic
    ///
    /// - **With pagination**: Uses SeaORM's `paginate()` method to fetch a specific page
    /// - **Without pagination**: Uses SeaORM's `all()` method to fetch all results
    ///
    /// # Buffer Management
    ///
    /// - Clears the existing buffer before loading new data
    /// - Stores all entity models directly in the buffer for sequential access
    ///
    /// # Error Handling
    ///
    /// Returns a `DbErr` if the database query fails. This error will be converted
    /// to a `BatchError` by the calling method.
    async fn read_page_async(&self) -> Result<(), DbErr> {
        let results = if let Some(page_size) = self.page_size {
            // Use SeaORM's paginator for efficient pagination
            // This creates a paginator that can fetch specific pages
            let paginator = self.query.clone().paginate(self.connection, page_size);
            let current_page = self.current_page.get();

            // Fetch the specific page we're currently on
            // Pages are 0-indexed in SeaORM's paginator
            paginator.fetch_page(current_page).await?
        } else {
            // Load all results at once - suitable for smaller datasets
            // This executes the query and returns all matching rows
            self.query.clone().all(self.connection).await?
        };

        // Clear the buffer and fill it with entity models
        let mut buffer = self.buffer.borrow_mut();
        buffer.clear(); // Remove any existing items from the previous page

        // Store entity models directly in the buffer
        buffer.extend(results);

        Ok(())
    }

    /// Reads a page of items from the database.
    ///
    /// This is a synchronous wrapper around the async `read_page_async` method.
    /// It uses tokio's `block_in_place` to run the async operation in a blocking context,
    /// which is necessary because the `ItemReader` trait is synchronous.
    ///
    /// # Async-to-Sync Bridge
    ///
    /// SeaORM is inherently async, but the batch framework uses synchronous traits
    /// for simplicity. This method bridges that gap by:
    /// 1. Using `block_in_place` to avoid blocking the tokio runtime
    /// 2. Getting the current runtime handle to execute the async operation
    /// 3. Converting SeaORM's `DbErr` to the batch framework's `BatchError`
    ///
    /// # Error Conversion
    ///
    /// Converts SeaORM's `DbErr` to `BatchError::ItemReader` with context information
    /// to help with debugging database-related issues.
    fn read_page(&self) -> Result<(), BatchError> {
        tokio::task::block_in_place(|| {
            tokio::runtime::Handle::current().block_on(async {
                self.read_page_async()
                    .await
                    .map_err(|e| BatchError::ItemReader(format!("SeaORM query failed: {}", e)))
            })
        })
    }
}

/// Implementation of ItemReader trait for OrmItemReader.
///
/// This implementation provides a way to read items from a database using SeaORM
/// with support for pagination. It uses an internal buffer to store the results
/// of database queries and keeps track of the current offset to determine when
/// a new page of data needs to be fetched.
///
/// # Reading Strategy
///
/// The reader implements a lazy-loading strategy:
/// 1. **First read**: Loads the first page of data
/// 2. **Subsequent reads**: Returns items from the buffer
/// 3. **Page boundary**: When the buffer is exhausted, loads the next page
/// 4. **End of data**: Returns None when no more data is available
///
/// # State Management
///
/// - `offset`: Tracks the absolute position across all pages
/// - `current_page`: Tracks which page we're currently reading from
/// - `buffer`: Holds the current page's data
///
/// The reader maintains these invariants:
/// - `offset` always represents the next item to be read
/// - `current_page` represents the page currently loaded in the buffer
/// - The buffer contains items for the current page only
impl<I> ItemReader<I::Model> for OrmItemReader<'_, I>
where
    I: EntityTrait,
    I::Model: FromQueryResult + Send + Sync + Clone,
{
    /// Reads the next item from the reader.
    ///
    /// This method manages pagination internally and provides a simple interface
    /// for sequential reading. The complexity of pagination is hidden from the caller.
    ///
    /// # Reading Algorithm
    ///
    /// 1. **Calculate buffer index**: Determine where we are within the current page
    /// 2. **Check if new page needed**: If at the start of a page, load new data
    /// 3. **Fetch from buffer**: Get the item at the current index
    /// 4. **Update counters**: Increment offset and page number as needed
    /// 5. **Return result**: Clone the item or return None if exhausted
    ///
    /// # Pagination Logic
    ///
    /// - **With pagination**: `index = offset % page_size`
    /// - **Without pagination**: `index = offset` (all data in one "page")
    /// - **New page trigger**: When `index == 0`, we need to load a new page
    /// - **Page advancement**: When we reach the end of a page, increment `current_page`
    ///
    /// # Memory Management
    ///
    /// Items are cloned when returned to ensure the caller owns the data.
    /// This prevents borrowing issues and allows the buffer to be modified
    /// for the next page load.
    ///
    /// # Returns
    ///
    /// - `Ok(Some(item))` if an item was successfully read
    /// - `Ok(None)` if there are no more items to read
    /// - `Err(BatchError)` if an error occurred during reading (e.g., database error)
    ///
    /// # Examples
    ///
    /// ```
    /// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
    /// use spring_batch_rs::core::item::ItemReader;
    /// use sea_orm::FromQueryResult;
    /// use serde::{Deserialize, Serialize};
    ///
    /// #[derive(Debug, Clone, FromQueryResult, Deserialize, Serialize)]
    /// struct Product {
    ///     id: i32,
    ///     name: String,
    ///     price: f64,
    /// }
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// // Assuming you have a database connection and query set up
    /// // let reader = OrmItemReaderBuilder::new()
    /// //     .connection(&db)
    /// //     .query(products::Entity::find())
    /// //     .page_size(50)
    /// //     .build();
    ///
    /// // Read all products
    /// // let mut products = Vec::new();
    /// // while let Some(product) = reader.read()? {
    /// //     products.push(product);
    /// // }
    /// # Ok(())
    /// # }
    /// ```
    fn read(&self) -> ItemReaderResult<I::Model> {
        // Calculate the index within the current page
        // This determines where we are in the current buffer
        let index = if let Some(page_size) = self.page_size {
            // With pagination: index is position within the current page
            self.offset.get() % page_size
        } else {
            // Without pagination: index is the absolute position
            self.offset.get()
        };

        // When index is 0, we've reached the start of a new page
        // or this is the first read operation, so we need to fetch data
        if index == 0 {
            self.read_page()?
        }

        // Retrieve the item at the current index from the buffer
        let buffer = self.buffer.borrow();
        let result = buffer.get(index as usize);

        match result {
            Some(item) => {
                // We found an item at the current position

                // Increment the offset for the next read operation
                // This moves us to the next item in the sequence
                self.offset.set(self.offset.get() + 1);

                // If we're using pagination and have reached the end of the current page,
                // increment the page number for the next page load
                if let Some(page_size) = self.page_size {
                    if self.offset.get() % page_size == 0 {
                        // We've read all items in the current page
                        // Move to the next page for the next read cycle
                        self.current_page.set(self.current_page.get() + 1);
                    }
                }

                // Clone the item to give ownership to the caller
                // This prevents borrowing conflicts with the buffer
                Ok(Some(item.clone()))
            }
            None => {
                // No more items in the current buffer
                // This means we've reached the end of the data

                // If we're using pagination, this might mean we've reached the end of all data
                // If not using pagination, this definitely means we're done
                Ok(None)
            }
        }
    }
}

/// Builder for creating a `OrmItemReader`.
///
/// This builder provides a convenient way to configure and create a `OrmItemReader`
/// with custom parameters like page size and database connection.
/// It follows the builder pattern to ensure all required components are provided
/// before creating the reader instance.
///
/// # Builder Pattern Benefits
///
/// - **Fluent API**: Method chaining for readable configuration
/// - **Compile-time Safety**: Required fields are enforced at build time
/// - **Flexibility**: Optional parameters can be omitted
/// - **Validation**: Build method validates all required components are present
///
/// # Required Components
///
/// The following components must be set before calling `build()`:
/// - **Connection**: Database connection for executing queries
/// - **Query**: SeaORM select query to execute
///
/// # Optional Components
///
/// - **Page Size**: When set, enables pagination for memory-efficient reading
///
/// # Usage Pattern
///
/// ```rust
/// // let reader = OrmItemReaderBuilder::new()
/// //     .connection(&db)           // Required
/// //     .query(entity_query)       // Required  
/// //     .page_size(100)           // Optional
/// //     .build();                 // Creates the reader
/// ```
///
/// # Examples
///
/// ```
/// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
/// use sea_orm::{Database, EntityTrait, FromQueryResult};
/// use serde::{Deserialize, Serialize};
///
/// #[derive(Debug, Clone, FromQueryResult, Deserialize, Serialize)]
/// struct Order {
///     id: i32,
///     customer_name: String,
///     total_amount: f64,
///     status: String,
/// }
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// // Create database connection
/// let db = Database::connect("postgresql://user:pass@localhost/db").await?;
///
/// // Create a query (assuming you have an orders entity)
/// // let query = orders::Entity::find()
/// //     .filter(orders::Column::Status.eq("pending"));
///
/// // Create the reader with explicit type annotations
/// // let reader: OrmItemReader<orders::Entity> = OrmItemReaderBuilder::new()
/// //     .connection(&db)
/// //     .query(query)
/// //     .page_size(100)  // Process 100 orders at a time
/// //     .build();
/// # Ok(())
/// # }
/// ```
pub struct OrmItemReaderBuilder<'a, I>
where
    I: EntityTrait,
{
    /// Database connection - None until set by the user
    /// This will be validated as required during build()
    connection: Option<&'a DatabaseConnection>,

    /// SeaORM select query - None until set by the user
    /// This will be validated as required during build()
    query: Option<Select<I>>,

    /// Optional page size for pagination
    /// When None, all data will be loaded at once
    /// When Some(size), data will be loaded in chunks
    page_size: Option<u64>,
}

impl<I> Default for OrmItemReaderBuilder<'_, I>
where
    I: EntityTrait,
{
    /// Creates a new builder with all fields set to None/default values.
    ///
    /// This is the starting point for the builder pattern. All required
    /// fields must be set before calling `build()`.
    fn default() -> Self {
        Self {
            connection: None,
            query: None,
            page_size: None,
        }
    }
}

impl<'a, I> OrmItemReaderBuilder<'a, I>
where
    I: EntityTrait,
    I::Model: FromQueryResult + Send + Sync + Clone,
{
    /// Sets the page size for the reader.
    ///
    /// When set, the reader will use pagination to load data in chunks of the specified size.
    /// This is useful for processing large datasets without loading everything into memory.
    ///
    /// # Memory Management
    ///
    /// - **Small page sizes** (e.g., 10-100): Lower memory usage, more database round trips
    /// - **Large page sizes** (e.g., 1000-10000): Higher memory usage, fewer database round trips
    /// - **No pagination** (None): All data loaded at once, highest memory usage
    ///
    /// # Performance Considerations
    ///
    /// - Choose page size based on available memory and network latency
    /// - Consider the size of your data rows when setting page size
    /// - Monitor memory usage and adjust as needed
    ///
    /// # Arguments
    ///
    /// * `page_size` - The number of items to read per page (must be > 0 for meaningful pagination)
    ///
    /// # Returns
    ///
    /// The updated `OrmItemReaderBuilder` instance for method chaining.
    ///
    /// # Examples
    ///
    /// ```
    /// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
    /// use sea_orm::FromQueryResult;
    /// use serde::{Deserialize, Serialize};
    ///
    /// // In practice, you would use actual SeaORM entities
    /// // #[derive(Debug, Clone, FromQueryResult)]
    /// // struct Record {
    /// //     id: i32,
    /// //     data: String,
    /// // }
    /// //
    /// // let builder = OrmItemReaderBuilder::<record::Entity>::new()
    /// //     .page_size(50);  // Process 50 records at a time
    /// ```
    pub fn page_size(mut self, page_size: u64) -> Self {
        self.page_size = Some(page_size);
        self
    }

    /// Sets the SeaORM select query for the reader.
    ///
    /// This query will be executed to fetch data from the database. The query can include
    /// filters, joins, ordering, and other SeaORM query operations. The query will be
    /// cloned for each page fetch, so it should be relatively lightweight to clone.
    ///
    /// # Query Design Considerations
    ///
    /// - **Ordering**: Include `ORDER BY` clauses for consistent pagination
    /// - **Filtering**: Apply filters to reduce the dataset size
    /// - **Joins**: Use joins to fetch related data in a single query
    /// - **Indexing**: Ensure proper database indexes for query performance
    ///
    /// # Pagination Compatibility
    ///
    /// When using pagination, the query should:
    /// - Have a deterministic order (use ORDER BY)
    /// - Not use LIMIT/OFFSET (handled by the paginator)
    /// - Be compatible with SeaORM's paginator
    ///
    /// # Arguments
    ///
    /// * `query` - The SeaORM select query to execute
    ///
    /// # Returns
    ///
    /// The updated `OrmItemReaderBuilder` instance for method chaining.
    ///
    /// # Examples
    ///
    /// ```
    /// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
    /// use sea_orm::{EntityTrait, QueryFilter};
    /// use serde::{Deserialize, Serialize};
    ///
    /// // In practice, you would use actual SeaORM entities
    /// // let query = user::Entity::find()
    /// //     .filter(user::Column::Active.eq(true))
    /// //     .order_by_asc(user::Column::Id);
    /// //
    /// // let builder = OrmItemReaderBuilder::<user::Entity>::new()
    /// //     .query(query);
    /// ```
    pub fn query(mut self, query: Select<I>) -> Self {
        self.query = Some(query);
        self
    }

    /// Sets the database connection for the reader.
    ///
    /// This connection will be used to execute the SeaORM queries. The connection
    /// must remain valid for the entire lifetime of the reader, which is enforced
    /// by the lifetime parameter 'a.
    ///
    /// # Connection Management
    ///
    /// - The connection is borrowed, not owned by the reader
    /// - Ensure the connection pool/manager outlives the reader
    /// - The connection should be properly configured for your database
    ///
    /// # Database Compatibility
    ///
    /// SeaORM supports multiple databases:
    /// - PostgreSQL
    /// - MySQL
    /// - SQLite
    /// - SQL Server (via sqlx)
    ///
    /// # Arguments
    ///
    /// * `connection` - The SeaORM database connection (must outlive the reader)
    ///
    /// # Returns
    ///
    /// The updated `OrmItemReaderBuilder` instance for method chaining.
    ///
    /// # Examples
    ///
    /// ```
    /// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
    /// use sea_orm::{Database, EntityTrait};
    /// use serde::{Deserialize, Serialize};
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let db = Database::connect("sqlite::memory:").await?;
    ///
    /// // In practice, you would use actual SeaORM entities
    /// // let builder = OrmItemReaderBuilder::<product::Entity>::new()
    /// //     .connection(&db);
    /// # Ok(())
    /// # }
    /// ```
    pub fn connection(mut self, connection: &'a DatabaseConnection) -> Self {
        self.connection = Some(connection);
        self
    }

    /// Builds the `OrmItemReader` instance.
    ///
    /// This method validates that all required components have been set and creates
    /// the final `OrmItemReader` instance. It performs compile-time validation
    /// to ensure the reader is properly configured.
    ///
    /// # Validation
    ///
    /// The build method checks that all required components are present:
    /// - Database connection must be set
    /// - Query must be set  
    ///
    /// If any required component is missing, the method will panic with a descriptive message.
    ///
    /// # Error Handling
    ///
    /// This method uses `expect()` to provide clear error messages when required
    /// components are missing. This is intentional as missing required components
    /// represent programming errors that should be caught during development.
    ///
    /// # Returns
    ///
    /// The built `OrmItemReader` instance, ready for use.
    ///
    /// # Panics
    ///
    /// Panics if any required component (connection or query) has not been set.
    /// The panic message will indicate which component is missing.
    ///
    /// # Examples
    ///
    /// ```
    /// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
    /// use sea_orm::{Database, EntityTrait, FromQueryResult};
    /// use serde::{Deserialize, Serialize};
    ///
    /// #[derive(Debug, Clone, FromQueryResult, Deserialize, Serialize)]
    /// struct Item {
    ///     id: i32,
    ///     name: String,
    /// }
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let db = Database::connect("sqlite::memory:").await?;
    /// // let query = items::Entity::find();
    ///
    /// // let reader = OrmItemReaderBuilder::new()
    /// //     .connection(&db)
    /// //     .query(query)
    /// //     .page_size(100)
    /// //     .build();
    /// # Ok(())
    /// # }
    /// ```
    pub fn build(self) -> OrmItemReader<'a, I> {
        OrmItemReader::new(
            self.connection.expect("Database connection is required"),
            self.query.expect("Query is required"),
            self.page_size,
        )
    }

    /// Creates a new `OrmItemReaderBuilder`.
    ///
    /// This is the entry point for the builder pattern. It creates a new builder
    /// instance with all fields set to their default values (None for optional fields).
    ///
    /// # Builder Lifecycle
    ///
    /// 1. **Creation**: `new()` creates an empty builder
    /// 2. **Configuration**: Use setter methods to configure the reader
    /// 3. **Validation**: `build()` validates and creates the final reader
    ///
    /// # Examples
    ///
    /// ```
    /// use spring_batch_rs::item::orm::OrmItemReaderBuilder;
    /// use sea_orm::EntityTrait;
    /// use serde::{Deserialize, Serialize};
    ///
    /// // In practice, you would use actual SeaORM entities
    /// // let builder = OrmItemReaderBuilder::<record::Entity>::new()
    /// //     .page_size(50);  // Process 50 records at a time
    /// ```
    pub fn new() -> Self {
        Self::default()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sea_orm::DbErr;
    use serde::{Deserialize, Serialize};

    // ============================================================================
    // Test Data Structures
    // ============================================================================

    #[derive(Debug, Clone, FromQueryResult, Deserialize, Serialize, PartialEq)]
    struct TestUser {
        id: i32,
        name: String,
        email: String,
    }

    // ============================================================================
    // Error Handling Tests
    // ============================================================================

    #[test]
    fn test_error_conversion_from_db_err() {
        let db_error = DbErr::Custom("Database connection failed".to_string());
        let batch_error = BatchError::ItemReader(format!("SeaORM query failed: {}", db_error));

        match batch_error {
            BatchError::ItemReader(msg) => {
                assert!(msg.contains("SeaORM query failed"));
                assert!(msg.contains("Database connection failed"));
            }
            _ => panic!("Expected ItemReader error"),
        }
    }

    #[test]
    fn test_error_conversion_with_custom_errors() {
        let test_cases = vec![
            "Database connection failed",
            "Query timeout",
            "Invalid SQL syntax",
            "Permission denied",
        ];

        for error_msg in test_cases {
            let db_error = DbErr::Custom(error_msg.to_string());
            let batch_error = BatchError::ItemReader(format!("SeaORM query failed: {}", db_error));

            match batch_error {
                BatchError::ItemReader(msg) => {
                    assert!(msg.contains("SeaORM query failed"));
                    assert!(msg.contains(error_msg));
                }
                _ => panic!("Expected ItemReader error"),
            }
        }
    }

    // ============================================================================
    // Memory Management Tests
    // ============================================================================

    #[test]
    fn test_clone_behavior() {
        let user = TestUser {
            id: 1,
            name: "Clone Test".to_string(),
            email: "clone@test.com".to_string(),
        };

        let cloned = user.clone();
        assert_eq!(user, cloned);

        // Ensure they are separate instances
        assert_ne!(user.name.as_ptr(), cloned.name.as_ptr());
        assert_ne!(user.email.as_ptr(), cloned.email.as_ptr());
    }

    // ============================================================================
    // Serialization Tests
    // ============================================================================

    #[test]
    fn test_serde_serialization() {
        let user = TestUser {
            id: 1,
            name: "Serde Test".to_string(),
            email: "serde@test.com".to_string(),
        };

        // Test JSON serialization
        let json = serde_json::to_string(&user).expect("Failed to serialize to JSON");
        assert!(json.contains("Serde Test"));
        assert!(json.contains("serde@test.com"));
        assert!(json.contains("\"id\":1"));

        // Test JSON deserialization
        let deserialized: TestUser =
            serde_json::from_str(&json).expect("Failed to deserialize from JSON");
        assert_eq!(user, deserialized);
    }

    #[test]
    fn test_serde_round_trip_with_special_characters() {
        let user = TestUser {
            id: 42,
            name: "Test \"User\" with 'quotes'".to_string(),
            email: "test+special@example.com".to_string(),
        };

        // Test round-trip serialization
        let json = serde_json::to_string(&user).expect("Failed to serialize");
        let deserialized: TestUser = serde_json::from_str(&json).expect("Failed to deserialize");

        assert_eq!(user, deserialized);
        assert_eq!(deserialized.name, "Test \"User\" with 'quotes'");
        assert_eq!(deserialized.email, "test+special@example.com");
    }

    // ============================================================================
    // Debug and Display Tests
    // ============================================================================

    #[test]
    fn test_debug_formatting() {
        let user = TestUser {
            id: 1,
            name: "Debug Test".to_string(),
            email: "debug@example.com".to_string(),
        };

        let debug_str = format!("{:?}", user);
        assert!(debug_str.contains("Debug Test"));
        assert!(debug_str.contains("debug@example.com"));
        assert!(debug_str.contains("1"));
        assert!(debug_str.contains("TestUser"));
    }

    // ============================================================================
    // Equality Tests
    // ============================================================================

    #[test]
    fn test_partial_eq_users() {
        let user1 = TestUser {
            id: 1,
            name: "Same".to_string(),
            email: "same@example.com".to_string(),
        };

        let user2 = TestUser {
            id: 1,
            name: "Same".to_string(),
            email: "same@example.com".to_string(),
        };

        let user3 = TestUser {
            id: 2,
            name: "Different".to_string(),
            email: "different@example.com".to_string(),
        };

        assert_eq!(user1, user2);
        assert_ne!(user1, user3);
        assert_ne!(user2, user3);
    }

    // ============================================================================
    // Type Safety Tests
    // ============================================================================

    #[test]
    fn test_entity_model_direct_usage() {
        // Test that we can work directly with entity models
        let user = TestUser {
            id: 123,
            name: "Direct Entity Test".to_string(),
            email: "entity@test.com".to_string(),
        };

        // Verify we can clone and use the entity model directly
        let cloned = user.clone();
        assert_eq!(user, cloned);
        assert_eq!(cloned.id, 123);
        assert_eq!(cloned.name, "Direct Entity Test");
        assert_eq!(cloned.email, "entity@test.com");
    }

    // ============================================================================
    // Performance and Stress Tests
    // ============================================================================

    #[test]
    fn test_large_entity_handling() {
        // Test with very large strings
        let large_name = "X".repeat(10000);
        let large_email = format!("{}@verylongdomain.com", "y".repeat(5000));

        let large_user = TestUser {
            id: 999999,
            name: large_name.clone(),
            email: large_email.clone(),
        };

        let cloned = large_user.clone();
        assert_eq!(large_user, cloned);
        assert_eq!(cloned.name.len(), 10000);
        assert_eq!(cloned.email.len(), 5000 + "@verylongdomain.com".len());
    }

    #[test]
    fn test_entity_with_extreme_numeric_values() {
        // Test with negative ID
        let negative_user = TestUser {
            id: -1,
            name: "Negative User".to_string(),
            email: "negative@example.com".to_string(),
        };
        let cloned_negative = negative_user.clone();
        assert_eq!(cloned_negative, negative_user);
        assert_eq!(cloned_negative.id, -1);

        // Test with maximum ID
        let max_user = TestUser {
            id: i32::MAX,
            name: "Max User".to_string(),
            email: "max@example.com".to_string(),
        };
        let cloned_max = max_user.clone();
        assert_eq!(cloned_max, max_user);
        assert_eq!(cloned_max.id, i32::MAX);

        // Test with minimum ID
        let min_user = TestUser {
            id: i32::MIN,
            name: "Min User".to_string(),
            email: "min@example.com".to_string(),
        };
        let cloned_min = min_user.clone();
        assert_eq!(cloned_min, min_user);
        assert_eq!(cloned_min.id, i32::MIN);
    }

    #[test]
    fn test_many_entity_operations() {
        // Test that we can handle many entity operations efficiently
        for i in 0..1000 {
            let user = TestUser {
                id: i,
                name: format!("User {}", i),
                email: format!("user{}@test.com", i),
            };

            let cloned = user.clone();
            assert_eq!(user, cloned);
            assert_eq!(cloned.id, i);
            assert_eq!(cloned.name, format!("User {}", i));
            assert_eq!(cloned.email, format!("user{}@test.com", i));
        }
    }

    // ============================================================================
    // Unicode and Special Character Tests
    // ============================================================================

    #[test]
    fn test_entity_with_unicode() {
        let user = TestUser {
            id: 1,
            name: "山田太郎".to_string(),
            email: "yamada@example.jp".to_string(),
        };

        let cloned = user.clone();
        assert_eq!(user, cloned);
        assert!(cloned.name.contains("山田太郎"));
        assert_eq!(cloned.email, "yamada@example.jp");
    }

    #[test]
    fn test_entity_with_special_characters() {
        let user = TestUser {
            id: 1,
            name: "José María O'Connor".to_string(),
            email: "jose.maria@example.com".to_string(),
        };

        let cloned = user.clone();
        assert_eq!(user, cloned);
        assert!(cloned.name.contains("José María O'Connor"));
        assert!(cloned.email.contains("jose.maria"));
    }

    #[test]
    fn test_entity_with_empty_data() {
        let user = TestUser {
            id: 0,
            name: "".to_string(),
            email: "".to_string(),
        };

        let cloned = user.clone();
        assert_eq!(user, cloned);
        assert_eq!(cloned.name, "");
        assert_eq!(cloned.email, "");
    }
}
